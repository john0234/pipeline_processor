Josh Johnson and Kelsey Faulise
CISC 340
Project 3 Overview Document

	Our simulator starts by taking in the file that contains the machine code in the main function. It then checks to see if there are the correct number of files in the command line. If there is only
one item on the command line, such as the command to run the program it will ask for the 
user to enter the file that they wish to run. It will then create space for the file. 
If there is a file it will create space for the file. If there are more than two files in 
the command it will print out an error message. If the file that is inputted is null, it
will then again print out an error message saying that it could not open the file. If the 
file does exist it will then it will then put then read in the file and count the number
of new lines. Then it will reset the file back to the beginning. After, it will create 
space for the two stateType. It will then set all of the arrays within the structs and setting various fields (cycles, fetched, etc) to zero for both the state and newState variables. It will then fill the data memory and instruction memory with the machine code. It will then fill the pipeline registers with NOOPs.  After, it will call the run(state, newState) function. 
	Run function: This function is what runs the simulator. It will start with a while loop that will run until it hits a halt in the write back phase. It first prints out the state of the machine so that you are able to see the registers and data memory. It will then check to see if there is a halt in the write back (WB) phase. If there is it prints out that the machine has halted, the total cycles executed, instructions fetched, instructions retired, branches executed, and total mispredictions. If this is true it will exit out of the while loop. Else, it will continue onto the step. 
It will set state to newState and increase the amount of cycles. 
It will then begin the Fetch stage (IF) . This goes to the IF function, which takes in two StateType pointers. It will take the instruction out of state instruction memory and store it into newState instruction. It will then check to see if the instruction in decode stage. If the instruction that we just took out of memory is an Add and regA is being use in decode or regB is being used in decode, then we put a stall into the pipeline.   It also checks for Nands, SW, and LWs. It again checks the fields to see the most recently fetched instructionâ€™s registers are being used. It will again put in a stall. If this is not an issue, it increments pc and sets newState->pcPlus1 to the current pc plus 1. It also increases the amount of fetched instruction is it does not equal 0. This completes the Fetch stage. It will then go the decode (ID) stage. 
	ID Stage: This function takes in two stateType pointers. It will set the IDEX instruction to the memory that is located in the IFID instruction. This then sets pcPlus1 one in IFID to the one in IDEX. It then sets offset, readRegA, and readRegB to zero, which will allow them to be set later. If then checks to see if the instruction in and Add or a Nand. If it is, it sets readRegA to field1 of the instruction and readRegB to field2 of the instruction. If it is not, it checks to see if the instruction is a LW, SW, or BEQ. If it is, it sets readRegA to field0, readRegB to field1 and sets offset to a sign extended version of field2. It them sets the IDEX readRegA and readRegB of what is in the designated register. It also sets the instruction, sets PCPlus1, and offset to their respective values. This concludes the ID stage and moves onto the EX stage. 
	EX Stage: This function takes in two stateType pointers to be used. It first sets two register variables to be used later. It then it sets, aluResult, branchTarget, and readReg to zero. It also, sets the EXMEM instruction to the instruction in IDEX. This next section deals with the data forwarding hazard. It first checks to see if the instruction is an Add. If it is it checks to see if RegA is being used in EXMEM as the destination field and the instruction in EXMEM is not beq. If it is true it takes the aluResult from EXMEM and puts it into RegA. If it is not it checks regA to see if it is being used in MEMWB as the destination and checks to make sure that the instruction is not BEQ. If these are all true it takes the writeData from EXMEM and puts it into regA. If it is not this case it checks to see if RegA is the destination reg in MEMWB and if so it sets the writeData in WBEND to RegA. After doing all of that, it checks RegB for all of the same parameters that were check on for RegA, such as if the destination registers is being ujsed in EXMEM or MEMWB. This will then determine what will be put into RegB. It will then add what is in RegA and RegB together to form aluResult. These steps will be repeated if the instruction is NAND. After this check has been completed it will nand regA and regB together. If it is not an Add or Nand it will check to see if it is a SW. This time it will do the same checks to see if the source reg is being used as the destination reg in either EXMEM or MEMWB. For the result, it will be set correctly to RegA. After, it will set RegA to readReg. If the instruction is not a SW, it checks to see if it is a LW. If it is, it calculates the target to reach what we want from memory, but setting aluResult to regB + offset. Finally, it checks to see if the instruction is BEQ. If it is, it is it checks to see if either of the two registers that it compares are in either the MEMWB or EXMEM stages to get the correct data from the future. Once it has gone through all of the checks it will subtract regA from RegB and set it to aluResult. It will also set the branch target to pcPlus1 plus offset. This is the completion of the EX stage. It will now move to the Mem stage. 
	MEMStage: This function takes in StateType pointers. It first sets the MEMWB instruction to the instruction that is in EXMEM. It then checks to see if the EXMEM instruction is an ADD. If it is, it sets aluResult to writeData. If it is a NAND, it also sets writeData to aluResult. If it is neither of those, it checks to see if the instructions are a LW or SW. If it is a LW, it sets writeData to the item in the dataMem location where the aluResult was set. If it is a SW, it sets what is in the readReg to dataMem at the location of aluResult. If it is neighter of those it checks to see if the instruction is BEQ. If it is, it checks the aluResult. If it is 0, we know that we are branching. If it is not we are not branching. If we are branching we increment the mispredicts because we predict that we are not branching. We then set the pc to the branchTarget, which is pcPlus1 + offset. We also flush the three stages above because we have loaded instructions that we did not want to load. This is the end of the MEM stage. We now move on to the WB stage. 
	WBStage: This function takes in two stateType pointers. It then sets WBEND instruction to the instruction in MEMWB. It them sets writeData to zero.  It then checks what the instruction is. If it is an ADD, if it is it sets the writeData to the writeData in MEMWB and it stores the writeData into the destination reg located in field0.  If it is not ADD, it checks if the instruction is a NAND> It again sets writeData to the writeData in MEMWB and sets the writeData to the destination register located in field0. If it is neither or those, it checks to see if the instruction is a LW. If it is, it puts the writeData into the registers located in the destination reg in MEMWB and sets writeData to writeData in MEMWB. After all of this has happened it increments the amount of retired instructions. This concludes the WB stage.
	Once it has gone through each of the function it sets newState to state using a deep clone, by dereferencing the pointers. This will then continue to loop around until it detects a halt in the MEMWB stage. This is how our simulator works.
	We ran into a few issues. The first issue that we ran into was that we were not doing a deep clone so when we were setting newState to state we were pointing at the same thing so every stage was the same. This was solved by adding the * to the two pointers. The next issue that we ran into, was trying to implement the data hazard. These were hard because we had to make sure that we were doing all of them in the correct place and getting the correct data at the right time. It took many hours but we were able to implement it. The last issues that we ran into and was not able to solve was calculating the correct number of retired instruction. This was hard because there were many cases such as the original NOOPs that are placed into the pipelines that we needed to account for and the NOOPs that we insert. Also, distinguishing between the NOOPS that we insert and the ones that are actually in the code. In the end we tried to solve the issue and it seems to work for all our test cases. Therefore, we think that we have solved the issue of calculating retired. 

